= 3. Многобитный сумматор

Напишем модуль, который может складывать двухбитные числа.
Для этого переиспользуем модуль `adder_logic_1_bit`, написанный в xref:02-combination-logic:index.adoc[прошлый раз].
Что логично, нужно использовать его два раза.
В первый раз, запишем бит переполнения во временную переменную.
После учтём её.
[source, verilog]
./src/03-principles-of-constructor/adder_reuse_without_generate.sv
----
include::example$adder_reuse_without_generate.sv[]
----
[NOTE]
====
Можно синтезировать схему написанного модуля.

image::adder_reuse_without_generate.svg[title="Схема двухбитного сложения"]

Как видно, вспомогательная переменная исчезла.
Точнее не исчезла, она представляет собой проводок из `c_out` первого блока в `c_in` второго блока.
Это вполне логично, эта переменная несёт в себе ровно этот смысл.
В SystemVerilog даже можно называть переменные `wire` (попробуйте заменить `logic` на `wire`).
====
В этом коде нет ничего нового, чего бы мы не знали.
Однако если мы попробуем написать сложение для `n`-ой размерности, то придётся `n` раз прописывать использование однобитного сложения.
Что никуда не годится, программисты придумали для такого циклы.
В SystemVerilog они тоже есть.

[source, verilog]
./src/03-principles-of-constructor/adder_multibits_reuse.sv
----
include::example$adder_multibits_reuse.sv[]
----
<1> Модули можно параметризовать{empty}footnote:[https://www.chipverify.com/verilog/verilog-parameters] и использовать параметр в любом месте модуля. Потом при инстанциации можно поставить то значение, которое хочется.
<2> Параметры можно использовать даже при описании входных и выходных данных. Очень мощный механизм, который обычно отсутствует (ну или является инструментом продвинутого уровня) в других языках.
<3> Задаём шину промежуточных битов переполнения.
<4> Начальный бит переполнения нужно учесть в промежуточной шине.
<5> Переменная, нужная только для генерации.
<6> Сейчас нужно много раз инстанциировать модуль `adder_logic_1_bit`, в SystemVerilog для решения этой проблемы можно генерировать код{empty}footnote:[https://www.chipverify.com/verilog/verilog-generate-block].
<7> Для каждого бита используем модуль однобитного сложения.
<8> Ну, и, что вполне логично, запоминаем бит переполнения для использования на следующем шаге (в школе про это говорилось "а один держим в уме").

Интересно посмотреть, во что синтезируется этот модуль.

image::adder_multibits_reuse.svg[title="Синтезированная схема многобитного сумматора"]

Тут видно, что блок модуля однобитного сложения используется четыре раза.
Что ожидаемо: он был вызван для каждого бита четырёхбитной шины.
Это напоминает нам о том, что, хоть они и похожи, но инстанциация модуля в SystemVerilog и вызов функции в привычных языках -- разные вещи.

[NOTE]
====
Можно добавить флаг `--flatten` в `prep` в xref:02-combination-logic:rtl_pics_synthesis.adoc[гайдике]. Он отвечает за то, будут ли при синтезе раскрываться используемые модули. Если это сделать, то синтезируется такая схема.

image::adder_multibits_reuse_flatten.svg[title="Развёрнутая схема многобитного сумматора"]
====

Ну, не стоит забывать, что всё это делается в учебных целях, и сложение битветоров реализовано, конечно, из коробки.

[source, verilog]
./src/03-principles-of-constructor/adder_multibits_bitvectors.sv
----
include::example$adder_multibits_bitvectors.sv[]
----

Схема для этого модуля будет выглядеть довольно просто.

image::adder_multibits_bitvectors_flatten.svg[title=" Схема многобитного сумматора на битвекторах"]

Человеку привычно воспринимать числа в десятичной записи, и в нормальных языках для такого есть отдельный тип `int`.
В этом смысле SystemVerilog тоже нормальный{empty}footnote:[https://www.chipverify.com/systemverilog/systemverilog-data-types-integer-byte].
Так что наш модуль в некотором смысле вырождается.

[source, verilog]
./src/03-principles-of-constructor/adder_multibits_int.sv
----
include::example$adder_multibits_int.sv[]
----

По умолчанию `int` -- знаковые числа, чтобы сделать их беззнаковыми, нужно писать `int unsigned`.

NOTE: У `int` другое поведение при переполнении: для знаковых чисел оно меняет знак, для беззнаковых -- уходит в 0.

image::adder_multibits_int_flatten.svg[title=" Схема многобитного сумматора с использованием int"]

IMPORTANT: Обязательно порешайте xref:exercises.adoc[упражнения].
